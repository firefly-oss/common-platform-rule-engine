# Python Compilation - Complete Guide

## üêç Overview

The Firefly Rule Engine supports compiling YAML DSL rules to executable Python code, enabling rule execution without the Java runtime. This comprehensive guide covers all aspects of Python compilation, from basic usage to advanced features.

## üöÄ Key Features

- **100% DSL Support**: All YAML DSL features are supported in Python compilation
- **Standalone Execution**: Generated Python code runs independently without Java dependencies
- **Database Integration**: Seamless integration with ConstantService for dynamic constants
- **Interactive Mode**: Built-in CLI interface for testing and debugging
- **Professional Quality**: Complete license headers, documentation, and error handling
- **Runtime Library**: Comprehensive Python library with 103+ built-in functions

## üèóÔ∏è Architecture

### Core Components

1. **PythonCodeGenerator**: AST visitor that generates Python code from parsed DSL
2. **PythonCompilationService**: Service layer managing compilation, caching, and statistics
3. **PythonCompiledRule**: Model representing compiled Python rule with metadata
4. **Python Runtime Library**: Complete Python library with all built-in functions
5. **REST API**: Endpoints for compilation, cache management, and statistics

### Compilation Pipeline

```mermaid
graph TD
    A[YAML DSL] --> B[AST Parser]
    B --> C[DSL Validation]
    C --> D[PythonCodeGenerator]
    D --> E[Constants Integration]
    E --> F[Python Code]
    F --> G[PythonCompiledRule]
    G --> H[Cache Storage]
    G --> I[API Response]
```

## üéØ Quick Start

### 1. Compile a Rule from YAML

```bash
curl -X POST http://localhost:8080/api/v1/python/compile \
  -H "Content-Type: text/plain" \
  -d 'name: "credit_check"
description: "Simple credit score validation"
version: "1.0.0"

input:
  creditScore: "number"

output:
  approved: "boolean"

when: creditScore >= 650
then:
  - set approved = true
else:
  - set approved = false'
```

### 2. Compile a Rule from Database

If you have rules already stored in the database, you can compile them directly:

**By Rule ID:**
```bash
# Get the rule ID from the database first
curl "http://localhost:8080/api/v1/rules/definitions" | jq '.content[0].id'

# Compile using the ID
curl -X POST "http://localhost:8080/api/v1/python/compile/rule/123e4567-e89b-12d3-a456-426614174000"
```

**By Rule Code:**
```bash
# Compile using the rule's unique code (easier to remember)
curl -X POST "http://localhost:8080/api/v1/python/compile/rule/code/credit_scoring_v1"
```

**Advantages of Database Compilation:**
- ‚úÖ **No YAML needed** - Rules are already validated and stored
- ‚úÖ **Version control** - Compile specific versions by ID
- ‚úÖ **Production ready** - Use rules that passed all validations
- ‚úÖ **Audit trail** - Full traceability of compiled rules

### 3. Install Python Runtime

```bash
# Install globally (macOS)
cd python-runtime
pip3 install --break-system-packages -e .

# Verify installation
python3 -c "import firefly_runtime; print('Runtime installed successfully!')"
```

### 4. Execute Generated Code

```python
# The generated Python file includes interactive execution
python3 compiled-rule.py

# Or import and use programmatically
from compiled_rule import credit_check
result = credit_check({'creditScore': 720})
print(result)  # {'approved': True}
```

## üìã Generated Python Code Structure

### Complete Example

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright 2025 Firefly Software Solutions Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Generated by Firefly Rule Engine Python Compiler
# Made with ‚ù§Ô∏è by Firefly Software Solutions Inc
# Compilation Date: 2025-09-15T13:46:07.887874+02:00

from firefly_runtime import *

def credit_check(context):
    """
    Rule: credit_check
    Simple credit score validation

    Args:
        context (dict): Execution context with input variables

    Returns:
        dict: Output variables
    """
    
    # Initialize constants from database or default values
    constants = {}
    constants['MIN_CREDIT_SCORE'] = 650  # Default value
    
    # Rule logic
    if context.get('creditScore', 0) >= constants['MIN_CREDIT_SCORE']:
        context['approved'] = True
    else:
        context['approved'] = False

    # Return output variables
    return {
        'approved': context.get('approved')
    }

if __name__ == "__main__":
    print_firefly_header("credit_check", "Simple credit score validation", "1.0.0")
    
    # Configure constants interactively if needed
    constants_need_config = []
    configure_constants_interactively(constants_need_config)
    
    # Collect input values
    context = collect_inputs({'creditScore': 'number'})
    
    # Execute rule
    print_execution_results(credit_check(context))
    
    print_firefly_footer()
```

## üîß Constants Integration

### Database vs Default Values

The compiler handles three scenarios for constants:

1. **Database Override**: Constants from database override default values
2. **Default Fallback**: Use default values when not in database
3. **Missing Constants**: Set to `None` with warnings

```python
# Initialize constants from database or default values
constants['EXISTING_CONSTANT'] = 999  # From database
constants['DEFAULT_ONLY_CONSTANT'] = 500  # Default value
constants['MISSING_CONSTANT'] = None  # WARNING: Not found
```

### Interactive Configuration

Generated code includes interactive constant configuration:

```python
if constants_need_config:
    print("‚ö†Ô∏è  WARNING: The following constants are not configured:")
    for const in constants_need_config:
        print(f"   - {const}")
    
    configure = input("\nüîß Would you like to configure them now? (y/n): ").lower()
    if configure == 'y':
        for const in constants_need_config:
            value = get_user_input(f"{const}: ", "auto")
            if value is not None:
                constants[const] = value
```

## üìö Python Runtime Library

### Complete Function Coverage (103 Functions)

#### Core Functions
- `firefly_get_nested_value()`, `firefly_get_indexed_value()`
- `firefly_is_empty()`, `firefly_is_not_empty()`
- `firefly_size()`, `firefly_count()`, `firefly_first()`, `firefly_last()`
- `firefly_average()`, `firefly_between()`, `firefly_exists()`

#### Financial Functions
- `firefly_calculate_loan_payment()`, `firefly_calculate_compound_interest()`
- `firefly_calculate_credit_score()`, `firefly_debt_to_income_ratio()`
- `firefly_credit_utilization()`, `firefly_loan_to_value()`
- `firefly_calculate_debt_ratio()`, `firefly_calculate_ltv()`

#### Validation Functions
- `firefly_validate_ssn()`, `firefly_validate_email()`, `firefly_validate_phone()`
- `firefly_is_positive()`, `firefly_is_negative()`, `firefly_is_zero()`
- `firefly_is_null()`, `firefly_is_not_null()`, `firefly_is_numeric()`

#### String Functions
- `firefly_upper()`, `firefly_lower()`, `firefly_trim()`
- `firefly_contains()`, `firefly_startswith()`, `firefly_endswith()`
- `firefly_replace()`, `firefly_matches()`, `firefly_length()`

#### Date/Time Functions
- `firefly_now()`, `firefly_today()`, `firefly_dateadd()`, `firefly_datediff()`
- `firefly_time_hour()`, `firefly_time_minute()`, `firefly_time_second()`

#### REST Client Functions
- `firefly_rest_get()`, `firefly_rest_post()`, `firefly_rest_put()`
- `firefly_rest_delete()`, `firefly_rest_patch()`, `firefly_rest_call()`

#### JSON Functions
- `firefly_json_extract()`, `firefly_json_exists()`, `firefly_json_size()`
- `firefly_json_keys()`, `firefly_json_values()`, `firefly_json_merge()`

#### Security Functions
- `firefly_encrypt()`, `firefly_decrypt()`, `firefly_hash()`
- `firefly_mask_data()`, `firefly_generate_uuid()`

#### Interactive Functions
- `get_user_input()`, `collect_inputs()`, `configure_constants_interactively()`
- `print_firefly_header()`, `print_execution_results()`, `print_firefly_footer()`

### HTTP Best Practices

The runtime includes validation for HTTP methods:

```python
# DELETE and GET requests should not have bodies
if method == 'DELETE' and body is not None:
    warnings.warn(
        "DELETE requests should not include a request body according to HTTP standards. "
        "The body parameter will be ignored.",
        UserWarning
    )
```

## üåê REST API Reference

### Compile Single Rule from YAML

**POST** `/api/v1/python/compile`

**Parameters:**
- `ruleName` (optional): Name for the rule
- `useCache` (default: true): Whether to use compilation cache

**Request Body:** YAML DSL rule definition (text/plain)

**Response:** PythonCompiledRule object

### Compile Rule from Database by ID

**POST** `/api/v1/python/compile/rule/{ruleId}`

Compiles a rule definition stored in the database using the rule's UUID.

**Path Parameters:**
- `ruleId` (required): UUID of the rule definition in the database

**Query Parameters:**
- `useCache` (default: true): Whether to use compilation cache

**Response:** PythonCompiledRule object

**Example:**
```bash
curl -X POST "http://localhost:8080/api/v1/python/compile/rule/123e4567-e89b-12d3-a456-426614174000?useCache=true"
```

### Compile Rule from Database by Code

**POST** `/api/v1/python/compile/rule/code/{ruleCode}`

Compiles a rule definition stored in the database using the rule's unique code identifier.

**Path Parameters:**
- `ruleCode` (required): Unique code of the rule definition (e.g., "credit_scoring_v1")

**Query Parameters:**
- `useCache` (default: true): Whether to use compilation cache

**Response:** PythonCompiledRule object

**Example:**
```bash
curl -X POST "http://localhost:8080/api/v1/python/compile/rule/code/credit_scoring_v1?useCache=true"
```

### Batch Compile Rules

**POST** `/api/v1/python/compile/batch`

**Request Body:** Map of rule names to YAML DSL definitions

### Cache Management

- **GET** `/api/v1/python/stats` - Get compilation statistics
- **DELETE** `/api/v1/python/cache` - Clear compilation cache
- **POST** `/api/v1/python/cache/check` - Check if rule is cached
- **POST** `/api/v1/python/cache/get` - Get cached compiled rule
- **DELETE** `/api/v1/python/cache/rule?ruleName=name` - Remove specific rule from cache

**Note**: The DELETE endpoint uses query parameters instead of request body to follow HTTP best practices.

### API Response Format

All compilation endpoints return a `PythonCompiledRule` object:

```json
{
  "ruleName": "credit_scoring_v1",
  "description": "Advanced credit scoring rule",
  "version": "1.0.0",
  "pythonCode": "#!/usr/bin/env python3\n# Generated Python code...",
  "functionName": "credit_scoring_v1",
  "inputVariables": ["creditScore", "income", "debtRatio"],
  "outputVariables": {
    "approved": "boolean",
    "maxLoanAmount": "number",
    "interestRate": "number"
  },
  "compiledAt": "2025-09-15T14:30:00Z",
  "sourceHash": "abc123def456"
}
```

### Error Responses

**404 Not Found** - Rule not found in database:
```json
{
  "error": "Rule definition not found",
  "message": "No rule definition found with ID: 123e4567-e89b-12d3-a456-426614174000",
  "ruleId": "123e4567-e89b-12d3-a456-426614174000"
}
```

**400 Bad Request** - Compilation error:
```json
{
  "error": "Compilation failed",
  "message": "Invalid DSL syntax: Missing 'when' clause",
  "ruleId": "123e4567-e89b-12d3-a456-426614174000",
  "ruleName": "credit_scoring_v1"
}
```

### Use Cases for Database Compilation

**1. Production Deployment**
- Compile rules that are already validated and stored in production database
- Ensure consistency between stored rules and compiled Python code
- Leverage existing rule management workflows

**2. CI/CD Integration**
```bash
# Compile all active rules for deployment
curl -X POST "http://localhost:8080/api/v1/python/compile/rule/code/credit_scoring_v1" \
  -o credit_scoring_v1.py

# Deploy compiled Python files to production environment
```

**3. Rule Versioning**
- Compile specific versions of rules by ID
- Maintain multiple compiled versions for A/B testing
- Rollback to previous rule versions quickly

**4. Automated Workflows**
```bash
# Get all rule definitions and compile them
rules=$(curl "http://localhost:8080/api/v1/rules/definitions")
for rule_id in $(echo $rules | jq -r '.content[].id'); do
  curl -X POST "http://localhost:8080/api/v1/python/compile/rule/$rule_id" \
    -o "compiled_rule_$rule_id.py"
done
```

## üß™ Testing

### Comprehensive Test Suite

- **52 Python Runtime Tests**: All runtime functions tested
- **17 Java Compiler Tests**: Complete compilation pipeline tested
- **HTTP Validation Tests**: REST client best practices validated
- **Integration Tests**: End-to-end compilation and execution

### Test Results

```
Python Runtime Tests: 52 passed, 0 failed
Java Compiler Tests: 17 passed, 0 failed
Total Coverage: 100% DSL feature support
```

## üéØ Advanced Features

### Complex DSL Support

The compiler supports all DSL features:

- **Multiple Rules**: Sequential rule execution
- **Conditional Blocks**: Nested if-then-else logic
- **Function Calls**: All 103+ built-in functions
- **Arithmetic Operations**: Mathematical expressions
- **JSON Path**: Data extraction from complex objects
- **REST Calls**: External API integration with proper HTTP validation

### Performance Optimization

- **AST Caching**: Parsed AST structures cached for reuse
- **Compilation Caching**: Compiled Python code cached by DSL hash
- **Parallel Processing**: Batch compilation uses parallel execution
- **Memory Management**: Efficient memory usage with configurable cache sizes

### Error Handling

- **Validation Errors**: DSL syntax and semantic validation
- **Compilation Errors**: Python code generation issues
- **Runtime Errors**: Execution-time error handling with detailed diagnostics
- **HTTP Validation**: Warnings for improper HTTP method usage

## üìñ Best Practices

### 1. Rule Design
- Use descriptive rule names for better Python function names
- Include comprehensive input/output type definitions
- Add meaningful descriptions for generated documentation

### 2. Compilation Strategy
- **Use database compilation** for production deployments
- **Use YAML compilation** for development and testing
- **Enable caching** for frequently compiled rules
- **Use rule codes** instead of IDs for better readability

### 3. Database Integration
- Store rules in database after thorough validation
- Use semantic versioning for rule versions
- Maintain active/inactive status for rule lifecycle management
- Tag rules appropriately for easy discovery

### 4. Performance
- Enable caching for frequently compiled rules
- Use batch compilation for multiple rules
- Monitor compilation statistics for optimization
- Compile rules during deployment, not at runtime

### 5. Testing
- Test both Java and Python execution for equivalence
- Validate edge cases and error conditions
- Use comprehensive test data sets
- Test compilation from both YAML and database sources

### 6. Deployment
- Install Python runtime dependencies in target environment
- Use virtual environments for isolation
- Monitor Python execution performance
- Automate rule compilation in CI/CD pipelines

### 7. API Usage
```bash
# Good: Use rule codes for readability
curl -X POST "/api/v1/python/compile/rule/code/credit_scoring_v1"

# Good: Enable caching for production
curl -X POST "/api/v1/python/compile/rule/code/credit_scoring_v1?useCache=true"

# Good: Handle errors gracefully
response=$(curl -s -w "%{http_code}" -X POST "/api/v1/python/compile/rule/code/invalid_rule")
if [[ "${response: -3}" != "200" ]]; then
  echo "Compilation failed"
fi
```

## üîó Integration with Existing Systems

### Rule Management Workflow

```mermaid
graph TD
    A[Create Rule in UI] --> B[Store in Database]
    B --> C[Validate DSL]
    C --> D[Activate Rule]
    D --> E[Compile to Python]
    E --> F[Deploy to Production]
    F --> G[Monitor Execution]
    G --> H[Update if Needed]
    H --> B
```

### CI/CD Pipeline Integration

```yaml
# .github/workflows/compile-rules.yml
name: Compile Rules to Python
on:
  push:
    branches: [main]

jobs:
  compile-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Get Active Rules
        run: |
          curl "${{ secrets.RULE_ENGINE_URL }}/api/v1/rules/definitions?isActive=true" \
            -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
            -o rules.json

      - name: Compile Rules
        run: |
          for rule_code in $(jq -r '.content[].code' rules.json); do
            curl -X POST "${{ secrets.RULE_ENGINE_URL }}/api/v1/python/compile/rule/code/$rule_code" \
              -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
              -o "compiled_rules/${rule_code}.py"
          done

      - name: Deploy to Production
        run: |
          # Deploy compiled Python files to your production environment
          rsync -av compiled_rules/ production:/opt/rules/
```

### Microservices Architecture

```python
# rule_compiler_service.py
import requests
import os

class RuleCompilerService:
    def __init__(self, rule_engine_url, api_token):
        self.base_url = rule_engine_url
        self.headers = {"Authorization": f"Bearer {api_token}"}

    def compile_rule_by_code(self, rule_code, use_cache=True):
        """Compile a rule from database by code"""
        url = f"{self.base_url}/api/v1/python/compile/rule/code/{rule_code}"
        params = {"useCache": use_cache}

        response = requests.post(url, headers=self.headers, params=params)
        response.raise_for_status()

        return response.json()

    def deploy_compiled_rule(self, rule_code, target_dir="/opt/rules"):
        """Compile and deploy a rule"""
        compiled_rule = self.compile_rule_by_code(rule_code)

        # Save compiled Python code
        file_path = os.path.join(target_dir, f"{rule_code}.py")
        with open(file_path, 'w') as f:
            f.write(compiled_rule['pythonCode'])

        return file_path

# Usage
compiler = RuleCompilerService("http://rule-engine:8080", "your-api-token")
compiler.deploy_compiled_rule("credit_scoring_v1")
```

## üîÆ Migration Guide

### From Java Execution to Python

1. **Identify rules** to migrate using the database endpoints
2. **Compile existing rules** using `/api/v1/python/compile/rule/code/{code}`
3. **Test equivalence** between Java and Python execution
4. **Deploy Python runtime** in target environment
5. **Update applications** to use compiled Python functions
6. **Monitor performance** and optimize as needed

### From YAML to Database Compilation

1. **Store rules** in database using `/api/v1/rules/definitions`
2. **Validate rules** using the validation endpoint
3. **Switch compilation** from YAML endpoints to database endpoints
4. **Update CI/CD** to use rule codes instead of YAML files
5. **Leverage rule management** features (versioning, activation, tags)

### Compatibility

- All DSL features are supported in Python compilation
- Function behavior is identical between Java and Python
- Error handling maintains the same semantics
- Performance characteristics may vary between platforms
- Database compilation provides additional metadata and traceability

## üìû Support

For questions and support:

- Check the [API Documentation](api-documentation.md)
- Review [YAML DSL Reference](yaml-dsl-reference.md)
- See [Developer Guide](developer-guide.md) for advanced topics
- Report issues in the project repository

---

*Made with ‚ù§Ô∏è by Firefly Software Solutions Inc*
